---
description: QEMU 환경에 로드한 OVMF 펌웨어 이미지 디버그 수행하기
---

# 41. DEBUG 출력문 내부 구조와 DEBUG 문 제어를 위한 PCD 분석, 그리고 OVMF 부트 로그 가져오기

이번 장에서는 edk2 코드 베이스에 존재하는 `DEBUG` 매크로와 관련된 정보를 학습한다. 다음은 그 예시이다.

```
DEBUG ((EFI_D_ERROR, "Hello Debug! Check this variable: %d\n", MyVar));
```

일반적인 출력 형식과 유사하지만 다른 기능이 존재한다.

* 로그 레벨을 이용하여 로그 메세지를 분류할 수 있다. PCD를 통한 구성으로 유형별 디버그 메세지를 쉽게 켜고 끌 수 있다.
* 서로 다른 UEFI 단계 및 모듈은 서로 다른 DEBUG 구현을 가지기 때문에 여러 DEBUG 기능 구현이 존재한다.

사전에 정의된 로그 메세지의 범주는 아래와 같다.\
[https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Library/DebugLib.h](https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Library/DebugLib.h)

```
#define DEBUG_INIT      0x00000001  // Initialization
#define DEBUG_WARN      0x00000002  // Warnings
#define DEBUG_LOAD      0x00000004  // Load events
#define DEBUG_FS        0x00000008  // EFI File system
#define DEBUG_POOL      0x00000010  // Alloc & Free (pool)
#define DEBUG_PAGE      0x00000020  // Alloc & Free (page)
#define DEBUG_INFO      0x00000040  // Informational debug messages
#define DEBUG_DISPATCH  0x00000080  // PEI/DXE/SMM Dispatchers
#define DEBUG_VARIABLE  0x00000100  // Variable
#define DEBUG_BM        0x00000400  // Boot Manager
#define DEBUG_BLKIO     0x00001000  // BlkIo Driver
#define DEBUG_NET       0x00004000  // Network Io Driver
#define DEBUG_UNDI      0x00010000  // UNDI Driver
#define DEBUG_LOADFILE  0x00020000  // LoadFile
#define DEBUG_EVENT     0x00080000  // Event messages
#define DEBUG_GCD       0x00100000  // Global Coherency Database changes
#define DEBUG_CACHE     0x00200000  // Memory range cachability changes
#define DEBUG_VERBOSE   0x00400000  // Detailed debug messages that may
                                    // significantly impact boot performance
#define DEBUG_ERROR     0x80000000  // Error
```

하지만 일반적으로 다음 별칭의 값이 사용된다.

```
//
// Aliases of debug message mask bits
//
#define EFI_D_INIT      DEBUG_INIT
#define EFI_D_WARN      DEBUG_WARN
#define EFI_D_LOAD      DEBUG_LOAD
#define EFI_D_FS        DEBUG_FS
#define EFI_D_POOL      DEBUG_POOL
#define EFI_D_PAGE      DEBUG_PAGE
#define EFI_D_INFO      DEBUG_INFO
#define EFI_D_DISPATCH  DEBUG_DISPATCH
#define EFI_D_VARIABLE  DEBUG_VARIABLE
#define EFI_D_BM        DEBUG_BM
#define EFI_D_BLKIO     DEBUG_BLKIO
#define EFI_D_NET       DEBUG_NET
#define EFI_D_UNDI      DEBUG_UNDI
#define EFI_D_LOADFILE  DEBUG_LOADFILE
#define EFI_D_EVENT     DEBUG_EVENT
#define EFI_D_VERBOSE   DEBUG_VERBOSE
#define EFI_D_ERROR     DEBUG_ERROR
```

DEBUG 매크로 자체 또한 `DebugLib`에 정의되어 있다.\
[https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Library/DebugLib.h](https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Library/DebugLib.h)

모든 전처리 과정을 분할하여 살펴보면 일반적으로다음과 같다.

```
if (DebugPrintEnabled ()) {
  if (DebugPrintLevelEnabled (PrintLevel)) {
    DebugPrint (PrintLevel, ##__VA_ARGS__);
  }
}
```

DEBUG 매크로 인터페이스는 `DebugLib` 헤더에 정의되어 있지만 실제 구현을 위해서는 사용되는 특정 라이브러리의 인터페이스를 살펴봐야 한다[https://github.com/tianocore/edk2/blob/master/OvmfPkg/OvmfPkgX64.dsc ](https://github.com/tianocore/edk2/blob/master/OvmfPkg/OvmfPkgX64.dsc) 를살펴보자

* `DebugLib` 은 각 UEFI 단계에서 각기 다른 구현을 가지고 있다.
* `DebugLib`은 `DEBUG_ON_SERAIL_PORT` 정의에 따라 다른 구현이 있다.

```
[LibraryClasses.common.SEC]
!ifdef $(DEBUG_ON_SERIAL_PORT)
  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
!else
  DebugLib|OvmfPkg/Library/PlatformDebugLibIoPort/PlatformRomDebugLibIoPort.inf
!endif
```

```
[LibraryClasses.common.PEI_CORE]
# [LibraryClasses.common.PEIM]
# [LibraryClasses.common.DXE_CORE]
# [LibraryClasses.common.DXE_RUNTIME_DRIVER]
# [LibraryClasses.common.UEFI_DRIVER]
# [LibraryClasses.common.DXE_DRIVER]
# [LibraryClasses.common.UEFI_APPLICATION]
# [LibraryClasses.common.DXE_SMM_DRIVER]
# [LibraryClasses.common.SMM_CORE]
!ifdef $(DEBUG_ON_SERIAL_PORT)
  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
!else
  DebugLib|OvmfPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
!endif
```

기본적으로 `DEBUG_ON_SERIAL_PORT`가 정의되어 있지 않은 경우 `PlatformDebugLibIoPort` 가 기본 라이브러리이다.\
[https://github.com/tianocore/edk2/tree/master/OvmfPkg/Library/PlatformDebugLibIoPort](https://github.com/tianocore/edk2/tree/master/OvmfPkg/Library/PlatformDebugLibIoPort)

```
DebugLib|OvmfPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf
```

`DEBUG` 매크로는 다음과 같이 번역된다.

```
if (DebugPrintEnabled ()) {
  if (DebugPrintLevelEnabled (PrintLevel)) {
    DebugPrint (PrintLevel, ##__VA_ARGS__);
  }
}
```

아래를 통해`DebugPrintEnabled`,`DebugPrintLevelEnabled` ,`DebugPrint` 정보를 살펴보자. [https://github.com/tianocore/edk2/blob/master/OvmfPkg/Library/PlatformDebugLibIoPort/DebugLib.c](https://github.com/tianocore/edk2/blob/master/OvmfPkg/Library/PlatformDebugLibIoPort/DebugLib.c)

#### DebugPrintEnabled

`DEBUG` 매크로는 먼저 `DebugPrintEnabled` 결과를 확인한다. 이 함수는 PCD의 `PcdDebugPropertyMask`에 `DEBUG_PROPERTY_DEBUG_PRINT_ENABLED`가 설정되어 있는지 확인한다.

```
BOOLEAN
EFIAPI
DebugPrintEnabled (
  VOID
  )
{
  return (BOOLEAN) ((PcdGet8(PcdDebugPropertyMask) & DEBUG_PROPERTY_DEBUG_PRINT_ENABLED) != 0);
}
```

#### DebugPrintLevelEnabled

그리고 `DebugPrintLevelEnabled` 함수는 전달된 `ErrorLevel` 이 PCD의 `PcdFixedDebugPrintErrorLevel` 에 있는지 확인한다.

```
BOOLEAN
EFIAPI
DebugPrintLevelEnabled (
  IN  CONST UINTN        ErrorLevel
  )
{
  return (BOOLEAN) ((ErrorLevel & PcdGet32(PcdFixedDebugPrintErrorLevel)) != 0);
}
```

**DebugPrint**

그런 다음 `DebugPrint` 함수가 실행되며 단순히 제어를 `DebugVPrint`로 전달한다.

```
VOID
EFIAPI
DebugPrint (
  IN  UINTN        ErrorLevel,
  IN  CONST CHAR8  *Format,
  ...
  )
{
  VA_LIST         Marker;

  VA_START (Marker, Format);
  DebugVPrint (ErrorLevel, Format, Marker);
  VA_END (Marker);
}
```

그리고 `DebugVPrint` 는 `DebugPrintMarker`로 제어를 전달한다.

```
VOID
EFIAPI
DebugVPrint (
  IN  UINTN         ErrorLevel,
  IN  CONST CHAR8   *Format,
  IN  VA_LIST       VaListMarker
  )
{
  DebugPrintMarker (ErrorLevel, Format, VaListMarker, NULL);
}
```

`DebugPrintMarker` 는 주요 디버그 기능으로, 전달된 `ErrorLevel` 이 `GetDebugPrintErrorLevel()` 출력에 있는지 확인한다. 최종적으로는 PCD의 `PcdDebugIoPort` 에 의해 정의된 입출력 포트에 디버그 문자열 쓰기를 수행한다.

```
VOID
DebugPrintMarker (
  IN  UINTN         ErrorLevel,
  IN  CONST CHAR8   *Format,
  IN  VA_LIST       VaListMarker,
  IN  BASE_LIST     BaseListMarker
  )
{
  CHAR8    Buffer[MAX_DEBUG_MESSAGE_LENGTH];
  UINTN    Length;

  //
  // If Format is NULL, then ASSERT().
  //
  ASSERT (Format != NULL);

  //
  // Check if the global mask disables this message or the device is inactive
  //
  if ((ErrorLevel & GetDebugPrintErrorLevel ()) == 0 ||
      !PlatformDebugLibIoPortFound ()) {
    return;
  }

  //
  // Convert the DEBUG() message to an ASCII String
  //
  if (BaseListMarker == NULL) {
    Length = AsciiVSPrint (Buffer, sizeof (Buffer), Format, VaListMarker);
  } else {
    Length = AsciiBSPrint (Buffer, sizeof (Buffer), Format, BaseListMarker);
  }

  //
  // Send the print string to the debug I/O port
  //
  IoWriteFifo8 (PcdGet16 (PcdDebugIoPort), Length, Buffer);
}
```

`GetDebugPrintErrorLevel()` 는 `DebugPrintErrorLevelLib` 라이브러리에 정의된 함수로 `OvmfPkgX64.dsc` 에서도 그 구현을 확인할 수 있다.

```
[LibraryClasses]
  ...
  DebugPrintErrorLevelLib|MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
```

소스를 보면 단순히 다른 PCD를 확인하는 것을 볼 수 있다.\
[https://github.com/tianocore/edk2/blob/master/MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.c](https://github.com/tianocore/edk2/blob/master/MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.c)

```
UINT32
EFIAPI
GetDebugPrintErrorLevel (
  VOID
  )
{
  //
  // Retrieve the current debug print error level mask from PcdDebugPrintErrorLevel.
  //
  return PcdGet32 (PcdDebugPrintErrorLevel);
}
```



### 요약

`DEBUG (( ErrorLevel, String, ... ))` 와 같은 형태의 코드를 정리하자면 다음과 같다.

1. `PcdDebugPropertyMask` 에 `DEBUG_PROPERTY_DEBUG_PRINT_ENABLED`가 있는지 확인한다.
2. 전달된 `ErrorLevel` 이 `PcdFixedDebugPrintErrorLevel` 에 설정되어 있는지 확인한다.
3. 전달된 `ErrorLevel` 이 `PcdDebugPrintErrorLevel` 에 설정되어 있는지 확인한다.
4. 지정된 형식 문자열을 `PcdDebugIoPort` 에 정의된 입출력 포트에 작성한다.

## Check if `PcdDebugPropertyMask` has `DEBUG_PROPERTY_DEBUG_PRINT_ENABLED`

OVMF의 DSC 파일에서는 PCD `PcdDebugPropertyMask` 를 다음과 같이 정의한다.\
[https://github.com/tianocore/edk2/blob/master/OvmfPkg/OvmfPkgX64.dsc](https://github.com/tianocore/edk2/blob/master/OvmfPkg/OvmfPkgX64.dsc:)

```
[PcdsFixedAtBuild]
!if $(SOURCE_DEBUG_ENABLE) == TRUE
  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x17
!else
  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x2F
!endif
```

그리고 이 PCD는 Shell용으로 재정의 된다.

```
[Components]
  ShellPkg/Application/Shell/Shell.inf {
    ...
    <PcdsFixedAtBuild>
    ...
    gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0xFF
  }
```

이 PCD에 대한 비트 정의는 다음에서 확인할 수 있다.\
[https://github.com/tianocore/edk2/blob/master/MdePkg/MdePkg.dec](https://github.com/tianocore/edk2/blob/master/MdePkg/MdePkg.dec)

```
## The mask is used to control DebugLib behavior.<BR><BR>
#  BIT0 - Enable Debug Assert.<BR>
#  BIT1 - Enable Debug Print.<BR>
#  BIT2 - Enable Debug Code.<BR>
#  BIT3 - Enable Clear Memory.<BR>
#  BIT4 - Enable BreakPoint as ASSERT.<BR>
#  BIT5 - Enable DeadLoop as ASSERT.<BR>
# @Prompt Debug Property.
# @Expression  0x80000002 | (gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask & 0xC0) == 0
gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0|UINT8|0x00000005
```

`SOURCE_DEBUG_ENABLE` 의 설정 값

* TRUE(17h): Debug Assert(1h)/Debug Print(2h)/Debug Code(4h)/BreakPoint(10h) 활성화
* FALSE(2Fh): Debug Assert(1h)/Debug Print(2h)/Debug Code(4h)/Clear Memory(8h)/DeadLoop(20h) 활성화

`DEBUG` 매크로에서 이 `PCD` 를 `DEBUG_PROPERTY_DEBUG_PRINT_ENABLED` 와 비교해보자.\
[https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Library/DebugLib.h](https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Library/DebugLib.h)

```
//
// Declare bits for PcdDebugPropertyMask
//
#define DEBUG_PROPERTY_DEBUG_ASSERT_ENABLED       0x01
#define DEBUG_PROPERTY_DEBUG_PRINT_ENABLED        0x02
#define DEBUG_PROPERTY_DEBUG_CODE_ENABLED         0x04
#define DEBUG_PROPERTY_CLEAR_MEMORY_ENABLED       0x08
#define DEBUG_PROPERTY_ASSERT_BREAKPOINT_ENABLED  0x10
#define DEBUG_PROPERTY_ASSERT_DEADLOOP_ENABLED    0x20
```

보다시피 해당 검사는 `SOURCE_DEBUG_ENABLE` 와 관계없이 통과된다.

## Checks if passed `ErrorLevel` is set in `PcdFixedDebugPrintErrorLevel`

해당 PCD는 `MdePkg.dsc` 에 정의되었다.\
[https://github.com/tianocore/edk2/blob/master/MdePkg/MdePkg.dec](https://github.com/tianocore/edk2/blob/master/MdePkg/MdePkg.dec:)

```
[PcdsFixedAtBuild]
  gEfiMdePkgTokenSpaceGuid.PcdFixedDebugPrintErrorLevel|0xFFFFFFFF|UINT32|0x30001016
```

이 PCD 정보는 OVMF의 DSC 파일에서 재정의 되지 않기 때문에 빌드에 포함되는 값이다. `0xFFFFFFFF` 는 DEBUG 메세지가 `EFI_D_*` 출력 레벨에 관계없이 이 검사를 통과함을 의미한다.

## Checks if passed `ErrorLevel` is set in `PcdDebugPrintErrorLevel`

해당 PCD는 `MdePkg.dec` 에 정의되었다.\
[https://github.com/tianocore/edk2/blob/master/MdePkg/MdePkg.dec](https://github.com/tianocore/edk2/blob/master/MdePkg/MdePkg.dec)

```
[PcdsFixedAtBuild]
  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel|0x80000000|UINT32|0x00000006
```

기본적으로 `MdePkg.dec` 및 `MdePkg.dsc` 에서 `0x80000000` 으로 정의된다.\
[https://github.com/tianocore/edk2/blob/master/MdePkg/MdePkg.dsc](https://github.com/tianocore/edk2/blob/master/MdePkg/MdePkg.dsc:)

```
[PcdsFixedAtBuild]
  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel|0x80000000
```

`0x80000000` 이라는 값은 오류 메시지(`EFI_D_ERROR`) 만 출력함을
