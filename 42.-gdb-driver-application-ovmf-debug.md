---
description: GDB 를 이용하여 QEMU 환경의 OVMF 이미지와 제작했던 드라이버/애플리케이션을 디버깅한다.
---

# 42. GDB를 이용한 Driver/Application 및 OVMF Debug

GDB를 사용하여 디버깅을 수행하기 위해서는 올바른 offset에 Debug Symbol을 로드해야 한다.

* 메모리 상의 app offset
* app 내부의 offset

이번 과정에서는 이전에 개발한 `ShowBootVariable.efi` 응용 프로그램을 디버깅한다.

## 메모리 상의 application offset 구하기

QEMU에서 OVMF를 실행한다.

```
qemu-system-x86_64 \
  -drive if=pflash,format=raw,readonly,file=Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd \
  -drive format=raw,file=fat:rw:~/UEFI_disk \
  -net none \
  -nographic \
  -global isa-debugcon.iobase=0x402 \
  -debugcon file:debug.log
```

또 다른 터미널을 이용하여 아래 명령어를 실행한다.

```
tail -f debug.log
```

이를 통해 런타임 로그를 추적할 수 있다.&#x20;

부팅 이후 `ShowBootVariables.efi` application을 실행하고 아래와 같은 메세지를 `debug.log` 에서 확인한다.

```
Loading driver at 0x00006649000 EntryPoint=0x0000664C80F ShowBootVariables.efi
InstallProtocolInterface: BC62157E-3E33-4FEC-9920-2D3B36D750DF 666B898
ProtectUefiImageCommon - 0x666B4C0
  - 0x0000000006649000 - 0x0000000000005540
InstallProtocolInterface: 752F3136-4E16-4FDC-A22A-E5F46812F4CA 7EA36C8
```

다음 문장에서 제작한 이미지가 로드된 주소를 확인한다. `0x6649000`

```
Loading driver at 0x00006649000 EntryPoint=0x0000664C80F ShowBootVariables.efi
```

## Application section의 offset 구하기

`objdump` 명령어를 이용하여 `.efi` 파일에 포함된 section을 확인한다.

```
$ objdump -h Build/UefiLessonsPkg/RELEASE_GCC5/X64/ShowBootVariables.efi


Build/UefiLessonsPkg/RELEASE_GCC5/X64/ShowBootVariables.efi:     file format pei-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00004d40  0000000000000240  0000000000000240  00000240  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000580  0000000000004f80  0000000000004f80  00004f80  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  2 .reloc        00000080  0000000000005500  0000000000005500  00005500  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA

```

또한 `.debug` 파일에 존재하는 section도 확인한다.

```
$ objdump -h Build/UefiLessonsPkg/RELEASE_GCC5/X64/ShowBootVariables.debug

Build/UefiLessonsPkg/RELEASE_GCC5/X64/ShowBootVariables.debug:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00004d15  0000000000000240  0000000000000240  000000c0  2**6
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         000004a1  0000000000004f80  0000000000004f80  00004e00  2**6
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .eh_frame     00000000  0000000000005440  0000000000005440  000052c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rela         00000510  0000000000005440  0000000000005440  000052c0  2**3
                  CONTENTS, READONLY
  4 .build-id     00000024  0000000000005950  0000000000005950  000057d0  2**2
                  CONTENTS, READONLY
  5 .debug_info   00026067  0000000000000000  0000000000000000  000057f4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  6 .debug_abbrev 00003553  0000000000000000  0000000000000000  0002b85b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_loc    00009fde  0000000000000000  0000000000000000  0002edae  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  8 .debug_aranges 00000570  0000000000000000  0000000000000000  00038d8c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  9 .debug_ranges 000013f0  0000000000000000  0000000000000000  000392fc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
 10 .debug_line   00008163  0000000000000000  0000000000000000  0003a6ec  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
 11 .debug_str    000065d7  0000000000000000  0000000000000000  0004284f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  000015a8  0000000000000000  0000000000000000  00048e28  2**3
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
```

두 정보의 차이는 `.debug` 정보의 유무이다.

objdump 결과를 통해서 필요한 section의 offset을 확인할 수 있다. (환경에 따라 그 결과가 다를 수도 있다.)

* `.text` -> `0x240`
* `.data` -> `0x4f40`

## GDB에 debug symbol 적용

QEMU 실행 시 `-s` 옵션을 포함하여 원격 디버깅을 활성화 한다. 해당 옵션은 `tcp::1234` 의 축어이며 QEMU는 해당 포트에서 GDB 연결을 수신할 수 있다.

```
qemu-system-x86_64 \
  -drive if=pflash,format=raw,readonly,file=Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd \
  -drive format=raw,file=fat:rw:~/UEFI_disk \
  -net none \
  -nographic \
  -s
```

symbol 적용을 위해 사전에 확인한 application 이미지 주소에 구한 `.text` 와  `.data` 의 offset 값 연산한다.

```
0x6649000 +  0x240 = 0x6649240
0x6649000 + 0x4f40 = 0x664df40
```

GDB를 실행하고 다음과 같이 symbol을 적용한다.

```
$ gdb
(gdb) add-symbol-file Build/UefiLessonsPkg/RELEASE_GCC5/X64/ShowBootVariables.debug 0x65FD240 -s .data 0x6601F80
add symbol table from file "Build/UefiLessonsPkg/RELEASE_GCC5/X64/ShowBootVariables.debug" at
	.text_addr = 0x65fd240
	.data_addr = 0x6601f80
(y or n) y
Reading symbols from Build/UefiLessonsPkg/RELEASE_GCC5/X64/ShowBootVariables.debug...
```

application의 진입점에 break point을 적용하기 위해서 `ShellAppMain` 함수를 검색한다.

```
$ grep -n ShellAppMain UefiLessonsPkg/ShowBootVariables/ShowBootVariables.c
63:INTN EFIAPI ShellAppMain(IN UINTN Argc, IN CHAR16 **Argv)
```

이후 진입점에 break point를 설정한다.

```
(gdb) b UefiLessonsPkg/ShowBootVariables/ShowBootVariables.c:63
Breakpoint 1 at 0x664c50f: file /home/kostr/tiano/edk2/UefiLessonsPkg/ShowBootVariables/ShowBootVariables.c, line 68.
```

원격 디버깅을 실행한다.

```
(gdb) target remote :1234
Remote debugging using :1234
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x000000000716e151 in ?? ()
```

연결 이후 QEMU는 중단되며 재실행을 위해서는 GDB에서 `c` 명령어를 입력하면 된다.

```
(gdb) c
Continuing.
```

설정한 break point를 trigger 하기 위해 application을 실행한다.

```
FS0:\> ShowBootVariables.efi
```

```
Breakpoint 1, ShellAppMain (Argc=1, Argv=0x6609b98)
    at /home/minishell/src/edk2-ws/edk2/UefiLessonsPkg/ShowBootVariables/ShowBootVariables.c:69
69	  Status = GetNvramVariable(L"BootCurrent", &gEfiGlobalVariableGuid, (VOID**)&BootCurrent, &OptionSize);
```

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

GDB에 편의를 위한 TUI 기능이 존재한다.

```
(gdb) tui enable
```

<figure><img src=".gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>



## &#x20;efi.py

앞선 과정들을 효율적으로 수행하기 위해서 Artem Nefedov 의 [efi.py](https://github.com/Kostr/UEFI-Lessons/blob/master/Lessons/Lesson\_42/efi.py) 스크립트를 사용한다.

해당 스크립트를 통해 debug symbols를 로드하는데 큰 도움을 받을 수 있다.\
[https://github.com/artem-nefedov/uefi-gdb/blob/master/efi.py](https://github.com/artem-nefedov/uefi-gdb/blob/master/efi.py)

```
gdb -ex 'source efi.py'
```

gdb 내부에서 추가된 `efi` 명령어를 이용해 debug symbols를 로드한다.

```
(gdb) efi -64 ShowBootVariables
Turning pagination off
Using pre-defined driver list: ['ShowBootVariables']
The target architecture is assumed to be i386:x86-64:intel
With architecture X64
Looking for addresses in debug.log
EFI file Build/UefiLessonsPkg/RELEASE_GCC5/X64/ShowBootVariables.efi
 Base address 0x000065FD000
.text address 0x0000000000000240
.data address 0x0000000000004f80
add symbol table from file "Build/UefiLessonsPkg/RELEASE_GCC5/X64/ShowBootVariables.debug" at
	.text_addr = 0x65fd240
	.data_addr = 0x6601f80
Restoring pagination

```

위 과정은 스크립트가 `ShowBootVariables` 문자열에 대해 `debug.log` 파일에서 검색하고 주소 정보를 가져온 다음 필요한 symbol을 구해 gdb에 로드한다.

디버깅을 시도해보면 앞선 과정과 동일한 결과를 얻을 수 있다.
