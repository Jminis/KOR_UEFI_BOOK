# 32. EFI\_PCI\_IO\_PROTOCOL을 사용해 PCI 옵션 ROM 이미지 표시

이번 장에서는 시스템의 PCI Device에 존재하는 OptionROM을 확인한다.

그래픽 카드와 같은 일부 PCI 장치는 BIOS 단계에서 작동하기 위해 추가적인 드라이버가 필요하다.

그러나 BIOS는 OS가 아니기 때문에 보드에 연결할 수 있는 모든 PCI 장치의 드라이버를 모두 포함할 수는 없다. 이런 문제를 해결하기 위해 복잡한 PCI 장치는 자체 펌웨어를 드라이버로 저장한다. 이게 PCI Option ROM으로 알려진 개념이다.\
[https://en.wikipedia.org/wiki/Option\_ROM](https://en.wikipedia.org/wiki/Option\_ROM)

BIOS는 모든 PCI 장치의 PCI 구성 공간을 쿼리하고 option ROM이 있는지 확인한다. BIOS가 있는 경우 BIOS 설정에 따라 option ROM에서 코드를 실해할 수 있다.

PCI Option ROM은 그 자체로 여러 코드 이미지를 가질 수 있다. 일반적인 경우는 option ROM에 두 개의 이미지가 포함되어 있다.

* driver for legacy BIOS (Legacy OpROM)
* driver for the UEFI BIOS (UEFI OpROM)

오래된 그래픽 카드는 Legacy BIOS용 드라이버만 포함할 수 있고, 최신/미래의 그래픽카드는 UEFI BIOS용 드라이버만 포함할 수 있다.

현재는 Legacy BIOS 인터페이스를 UEFI 전환하고 있다. UEFI 펌웨어는 Legacy OpROM과 함께 동작할 수 없다. 그러나 현재 Vendor들은 여전히 CSM 모드를 통해 Legacy 인터페이스로 작업할 수 있도록 했다.

하지만 UEFI OpROM만 로드하도록 BIOS를 설정하고 그래픽 카드에는 Legacy OpROM만 포함되어 있으면 화면 출력을 확인할 수 없다.

또한 OptionROM은 다양한 CPU 아키텍처를 위한 다양한 코드 이미지를 가지고 있으므로 PCI 디바이스는 ARM CPU와 x86 CPU 모두 동작할 수 있다.

PCI 장치에 어떤 옵션이 포함되어 있는지 확인하는 것은 흥미로울 수 있다. 그러니 이제  UEFI Shell 유틸리티를 작성한다.

### EFI\_PCI\_IO\_PROTOCOL

PCI 디바이스에 접근하려면 `EFI_PCI_IO_PROTOCOL`을 사용해야 한다.\
[https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/PciRootBridgeIo.h](https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/PciRootBridgeIo.h)

```
typedef struct _EFI_PCI_IO_PROTOCOL {
EFI_PCI_IO_PROTOCOL_POLL_IO_MEM PollMem;
 EFI_PCI_IO_PROTOCOL_POLL_IO_MEM PollIo;
 EFI_PCI_IO_PROTOCOL_ACCESS Mem;
 EFI_PCI_IO_PROTOCOL_ACCESS Io;
 EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS Pci;
 EFI_PCI_IO_PROTOCOL_COPY_MEM CopyMem;
 EFI_PCI_IO_PROTOCOL_MAP Map;
 EFI_PCI_IO_PROTOCOL_UNMAP Unmap;
 EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER AllocateBuffer;
 EFI_PCI_IO_PROTOCOL_FREE_BUFFER FreeBuffer;
 EFI_PCI_IO_PROTOCOL_FLUSH Flush;
 EFI_PCI_IO_PROTOCOL_GET_LOCATION GetLocation;
 EFI_PCI_IO_PROTOCOL_ATTRIBUTES Attributes;
 EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES GetBarAttributes;
 EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES SetBarAttributes;
 UINT64 RomSize;
 VOID *RomImage;
} EFI_PCI_IO_PROTOCOL;
```

보면 알 수 있듯이 `EFI_PCI_IO_PROTOCOL`은 `EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL`과 유사하다. 아래는 이 둘을 비교한 것이다.

```
typedef struct _EFI_PCI_IO_PROTOCOL {                        typedef struct _EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL {
                                                              EFI_HANDLE ParentHandle;
 EFI_PCI_IO_PROTOCOL_POLL_IO_MEM PollMem;                     EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_POLL_IO_MEM PollMem;
 EFI_PCI_IO_PROTOCOL_POLL_IO_MEM PollIo;                      EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_POLL_IO_MEM PollIo;
 EFI_PCI_IO_PROTOCOL_ACCESS Mem;                              EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_ACCESS Mem;
 EFI_PCI_IO_PROTOCOL_ACCESS Io;                               EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_ACCESS Io;
 EFI_PCI_IO_PROTOCOL_CONFIG_ACCESS Pci;                       EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_ACCESS Pci;
 EFI_PCI_IO_PROTOCOL_COPY_MEM CopyMem;                        EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_COPY_MEM CopyMem;
 EFI_PCI_IO_PROTOCOL_MAP Map;                                 EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_MAP Map;
 EFI_PCI_IO_PROTOCOL_UNMAP Unmap;                             EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_UNMAP Unmap;
 EFI_PCI_IO_PROTOCOL_ALLOCATE_BUFFER AllocateBuffer;          EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_ALLOCATE_BUFFER AllocateBuffer;
 EFI_PCI_IO_PROTOCOL_FREE_BUFFER FreeBuffer;                  EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_FREE_BUFFER FreeBuffer;
 EFI_PCI_IO_PROTOCOL_FLUSH Flush;                             EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_FLUSH Flush;
 EFI_PCI_IO_PROTOCOL_GET_LOCATION GetLocation;
 EFI_PCI_IO_PROTOCOL_ATTRIBUTES Attributes;
 EFI_PCI_IO_PROTOCOL_GET_BAR_ATTRIBUTES GetBarAttributes;     EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_GET_ATTRIBUTES GetAttributes;
 EFI_PCI_IO_PROTOCOL_SET_BAR_ATTRIBUTES SetBarAttributes;     EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_SET_ATTRIBUTES SetAttributes;
 UINT64 RomSize;
 VOID *RomImage;
                                                              EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL_CONFIGURATION Configuration;
                                                              UINT32 SegmentNumber;
} EFI_PCI_IO_PROTOCOL;                                       } EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL;
```

주요 차이점은 `EFI_PCI_IO_PROTOCOL`이 시스템의 모든 PCI 장치에 연결되어 있으면 `EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL`은 PCI Root Bridges에만 연결되어 있다는 점이다.

PCI OptionROM에 접근하려면 `EFI_PCI_IO_PROTOCOL`에서 아래와 같은 매개변수를 사용해야 한다.

```
RomSize 	The size, in bytes, of the ROM image.
RomImage 	A pointer to the in memory copy of the ROM image. The PCI Bus Driver is responsible
		for allocating memory for the ROM image, and copying the contents of the ROM to memory.
		The contents of this buffer are either from the PCI option ROM that can be accessed
		through the ROM BAR of the PCI controller, or it is from a platformspecific location.
		The Attributes() function can be used to determine from which of these two sources 
		the RomImage buffer was initialized
```

먼저 `EFI_PCI_IO_PROTOCOL`을 사용해 시스템의 PCI 장치를 확인한다. 로직은 이전 장에서 사용했던 것과 비슷하다.\
먼저 `LocateHandleBuffer` API를 통해 `EFI_PCI_IO_PROTOCOL` 프로토콜이 있는 모든 핸들을 찾은 다음 `OpenProtocol`을 호출해 각 프로토콜을 가져올 수 있다. 모든 프로토콜에서 `PrintPCI`를 사용한다.\
이번 앱은 `PCIRomInfo.efi`로 생성한다.

```
EFI_STATUS
EFIAPI
UefiMain (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  EFI_STATUS             Status;
  UINTN                  HandleCount;
  EFI_HANDLE             *HandleBuffer;
  Status = gBS->LocateHandleBuffer(
                  ByProtocol,
                  &gEfiPciIoProtocolGuid,
                  NULL,
                  &HandleCount,
                  &HandleBuffer
                );
  if (EFI_ERROR (Status)) {
    Print(L"Can't locate EFI_PCI_IO_PROTOCOL: %r\n", Status);
    return Status;
  }

  //Print(L"Number of PCI devices in the system: %d\n", HandleCount);
  EFI_PCI_IO_PROTOCOL* PciIo;
  for (UINTN Index = 0; Index < HandleCount; Index++) {
    Status = gBS->OpenProtocol (
                    HandleBuffer[Index],
                    &gEfiPciIoProtocolGuid,
                    (VOID **)&PciIo,
                    ImageHandle,
                    NULL,
                    EFI_OPEN_PROTOCOL_GET_PROTOCOL
                  );
    if (EFI_ERROR(Status)) {
      Print(L"Can't open protocol: %r\n", Status);
      return Status;
    }
    Status = PrintPCI(PciIo);
    if (EFI_ERROR(Status)) {
      Print(L"Error in PCI printing\n");
    }

  }
  FreePool(HandleBuffer);

  return EFI_SUCCESS;
}
```

`EFI_PCI_IO_PROTOCOL`이 있으면 `GetLocation()`을 통해 현재 PCI 컨트롤러의 주소를 확인할 수 있다.

```
EFI_PCI_IO_PROTOCOL.GetLocation()

Summary:
Retrieves this PCI controller’s current PCI bus number, device number, and function number.

Prototype:
typedef
EFI_STATUS
(EFIAPI *EFI_PCI_IO_PROTOCOL_GET_LOCATION) (
 IN EFI_PCI_IO_PROTOCOL *This,
 OUT UINTN *SegmentNumber,
 OUT UINTN *BusNumber,
 OUT UINTN *DeviceNumber,
 OUT UINTN *FunctionNumber
 );

Parameters:
This 		A pointer to the EFI_PCI_IO_PROTOCOL instance.
SegmentNumber 	The PCI controller’s current PCI segment number.
BusNumber 	The PCI controller’s current PCI bus number.
DeviceNumber 	The PCI controller’s current PCI device number.
FunctionNumber 	The PCI controller’s current PCI function number.

Description:
The GetLocation() function retrieves a PCI controller’s current location on a PCI Host Bridge. This is
specified by a PCI segment number, PCI bus number, PCI device number, and PCI function number. These
values can be used with the PCI Root Bridge I/O Protocol to perform PCI configuration cycles on the PCI
controller, or any of its peer PCI controller’s on the same PCI Host Bridge.
```

이제 `PrintPCI` 함수를 작성한다.

```c
EFI_STATUS PrintPCI(EFI_PCI_IO_PROTOCOL* PciIo)
{
  UINTN SegmentNumber;
  UINTN BusNumber;
  UINTN DeviceNumber;
  UINTN FunctionNumber;
  EFI_STATUS Status = PciIo->GetLocation(PciIo,
                                         &SegmentNumber,
                                         &BusNumber,
                                         &DeviceNumber,
                                         &FunctionNumber);
  if (EFI_ERROR(Status)) {
    Print(L"Error in getting PCI location: %r\n", Status);
    return Status;
  }

  PCI_DEVICE_INDEPENDENT_REGION PCIConfHdr;
  Status = PciIo->Pci.Read(PciIo,
                           EfiPciIoWidthUint8,
                           0,
                           sizeof(PCI_DEVICE_INDEPENDENT_REGION),
                           &PCIConfHdr);

  if (EFI_ERROR(Status)) {
    Print(L"Error in reading PCI conf space: %r\n", Status);
    return Status;
  }

  Print(L"%02x:%02x.%02x - Vendor:%04x, Device:%04x\n", BusNumber,
                                                      DeviceNumber,
                                                      FunctionNumber,
                                                      PCIConfHdr.VendorId,
                                                      PCIConfHdr.DeviceId);
    
  return Status;
}
```

`GetLocation` API를 사용한 후 Pci.Read를 호출하여 이전 장과 같이 PCI 구성 공간을 읽는다.

이번 앱에 필요한 헤더 파일은 아래와 같다.

<pre class="language-c"><code class="lang-c">#include &#x3C;Library/UefiBootServicesTableLib.h>
#include &#x3C;Library/UefiLib.h>
<strong>
</strong><strong>#include &#x3C;Protocol/PciIo.h>
</strong>#include &#x3C;Library/MemoryAllocationLib.h>
#include &#x3C;IndustryStandard/Pci.h>
#include &#x3C;Library/PrintLib.h></code></pre>

\*.inf 파일에도 Protocol을 추가한다.

```
[Protocols]
  gEfiPciIoProtocolGuid
```

앱을 빌드하고 실행하면 `EFI_PCI_ROOT_BRIDGE_IO_PROTOCOL`로 확인한 것과 동일한 PCI 장치 목록을 확인할 수 있다.

```
FS0:\> PCIRomInfo.efi
00:00.00 - Vendor:8086, Device:1237
00:01.00 - Vendor:8086, Device:7000
00:01.01 - Vendor:8086, Device:7010
00:01.03 - Vendor:8086, Device:7113
00:02.00 - Vendor:1234, Device:1111
```

