---
description: 어플리케이션 프로토콜에 대한 기본적인 사용
---

# 7. Handle/Protocol 데이터 베이스 구조 - Part 2

이번 장에서는 `IMAGE_HANDLE`에 존재하는 프로토콜의 GUID를 출력하는  것이 목표다.\
시작하기 앞서서 edk2 codebase에서 내부적으로 `EFI_GUID`가 무엇을 뜻하는지 이해해야 한다.\
([https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Uefi/UefiBaseType.h](https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Uefi/UefiBaseType.h))

```c
///
/// 128-bit buffer containing a unique identifier value.
///
typedef GUID                      EFI_GUID;
```

GUID 구조는 아래의 링크에 정의되어있다.\
([https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Base.h](https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Base.h))

```c
///
/// 128 bit buffer containing a unique identifier value.
/// Unless otherwise specified, aligned on a 64 bit boundary.
///
typedef struct {
  UINT32  Data1;
  UINT16  Data2;
  UINT16  Data3;
  UINT8   Data4[8];
} GUID;
```

GUID는 위와 같이 4Byte-2Byte-2Byte-8Byte로 구성되어 있다. 다행히도 위와 같은 구조체의 필드 하나씩 직접 뽑아줄 필요가 없다는 것이다.\
`Print` 함수의 `%g` 옵션을 사용하면 GUIDs가 출력되기 때문에 간편하게 출력할 수 있다.\
`Print` 옵션에 대해서는 아래 링크에 자세히 설명되어 있다.\
([https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Library/PrintLib.h](https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Library/PrintLib.h))

```
/// Printing Guid Using %g Option
Print("GUID=%g\n", myGUID);
```

우리는 PROTOCOL\_INTERFACE 구조에서 참조되는 PROTOCOL\_ENTRY의 EFI\_GUID 필드를 출력할 것이다.\
따라서 이전 챕터에서 언급한 것과 동일한 이유로 구조를 재정의 해야한다.

```c
typedef struct {
  UINTN               Signature;
  /// Link Entry inserted to mProtocolDatabase
  LIST_ENTRY          AllEntries;
  /// ID of the protocol
  EFI_GUID            ProtocolID;
  /// All protocol interfaces
  LIST_ENTRY          Protocols;
  /// Registerd notification handlers
  LIST_ENTRY          Notify;
} PROTOCOL_ENTRY;

typedef struct {
  UINTN                       Signature;
  /// Link on IHANDLE.Protocols
  LIST_ENTRY                  Link;
  /// Back pointer
  IHANDLE                     *Handle;
  /// Link on PROTOCOL_ENTRY.Protocols
  LIST_ENTRY                  ByProtocol;
  /// The protocol ID
  PROTOCOL_ENTRY              *Protocol;
  /// The interface value
  VOID                        *Interface;
  /// OPEN_PROTOCOL_DATA list
  LIST_ENTRY                  OpenList;
  UINTN                       OpenListCount;

} PROTOCOL_INTERFACE;
```

이전 챕터에서 설명한 것과 동일하게 LINK는 다른 PROTOCOL\_INTERFACE에 존재하는 LIST\_ENTRY구조를 가리킨다(double-linked list). 아래는 이를 간략하게 표헌한 모습이다.

```c
typedef struct {                                         typedef struct {
  UINTN                       Signature;                   UINTN                       Signature;
  struct LIST_ENTRY {                          |---------> struct LIST_ENTRY {
    LIST_ENTRY  *ForwardLink; -----------------|             LIST_ENTRY  *ForwardLink;
    LIST_ENTRY  *BackLink;                                   LIST_ENTRY  *BackLink;
  } Link;                                                  } Link;
  IHANDLE                     *Handle;                     IHANDLE                     *Handle;
  LIST_ENTRY                  ByProtocol;                  LIST_ENTRY                  ByProtocol;
  PROTOCOL_ENTRY              *Protocol;                   PROTOCOL_ENTRY              *Protocol;
  VOID                        *Interface;                  VOID                        *Interface;
  LIST_ENTRY                  OpenList;                    LIST_ENTRY                  OpenList;
  UINTN                       OpenListCount;               UINTN                       OpenListCount;
} PROTOCOL_INTERFACE;   
```

하지만 우리는 `Link` 필드의 `ForwardLink`나 `BackLink`가 필요한 것이 아닌 `PROTOCOL_INTERFACE` 구조 자체에 대한 포인터가 필요하다.\
따라서 아래와 같이 몇가지 매크로에 대한 정의가 필요하다. 해당 매크로는 Linux 커널 프로그래밍을 공부했다면 친숙하게 느껴질 수도 있다. 혹시라도 모를 사람을 위해서 자세히 설명된 링크를 아래에 첨부하겠다.\
([https://www.bhral.com/post/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90%EC%9D%98-container\_of-%EB%A7%A4%ED%81%AC%EB%A1%9C](https://www.bhral.com/post/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90%EC%9D%98-container\_of-%EB%A7%A4%ED%81%AC%EB%A1%9C))

```c
#define offsetof(a,b) ((INTN)(&(((a*)(0))->b)))
c
#define container_of(ptr, type, member) ({                      \
        const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
        (type *)( (char *)__mptr - offsetof(type,member) );})
```

간략하게 설명을 하면 `container_of` 매크로는 포인터(`ptr`)가 가리키는 구조체 멤버(`member`)를포함하는 구조체(`type`)의 주소를 반환한다고 생각하면 된다.

이 모든 점들을 가지고 UefiMain 함수의 최종코드를 작성한다.

```c
EFI_STATUS
EFIAPI
UefiMain (
  IN EFI_HANDLE        ImageHandle,
  IN EFI_SYSTEM_TABLE  *SystemTable
  )
{
  IHANDLE* MyHandle = ImageHandle;
  Print(L"Signature: %c %c %c %c\n", (MyHandle->Signature >>  0) & 0xff,
                                     (MyHandle->Signature >>  8) & 0xff,
                                     (MyHandle->Signature >> 16) & 0xff,
                                     (MyHandle->Signature >> 24) & 0xff);

  Print(L"Back Protocol Interface Link: %p\n", MyHandle->Protocols.BackLink);
  Print(L"Forward Protocol Interface Link: %p\n", MyHandle->Protocols.ForwardLink);

  LIST_ENTRY *FirstLink = MyHandle->Protocols.ForwardLink;
  LIST_ENTRY *CurrentLink = FirstLink;
  do {
        PROTOCOL_INTERFACE* MyProtocolInterface = container_of(CurrentLink, PROTOCOL_INTERFACE, Link);

        Print(L"\n");
        Print(L"Current Link: %p\n", CurrentLink);
        Print(L"Signature: %c %c %c %c\n", (MyProtocolInterface->Signature >>  0) & 0xff,
                                           (MyProtocolInterface->Signature >>  8) & 0xff,
                                           (MyProtocolInterface->Signature >> 16) & 0xff,
                                           (MyProtocolInterface->Signature >> 24) & 0xff);

        Print(L"Back Link: %p\n", MyProtocolInterface->Link.BackLink);
        Print(L"Forward Link: %p\n", MyProtocolInterface->Link.ForwardLink);
        Print(L"GUID=%g\n", MyProtocolInterface->Protocol->ProtocolID);
        CurrentLink = MyProtocolInterface->Link.ForwardLink;
  } while (CurrentLink != FirstLink);

  return EFI_SUCCESS;
}
```

![](<.gitbook/assets/image (5).png>)











